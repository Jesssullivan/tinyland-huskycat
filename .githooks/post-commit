#!/usr/bin/env bash
# HuskyCat post-commit hook: auto-triage (non-blocking)
#
# Runs triage in the background after every commit.
# Detects issues/MRs from branch names, auto-labels,
# and sets iterations to the current week.
#
# Control:
#   SKIP_TRIAGE=1       - Skip triage entirely
#   TRIAGE_DRY_RUN=1    - Dry run mode
#   TRIAGE_FOREGROUND=1  - Run in foreground for debugging

# shellcheck source=_/common.sh
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/_/common.sh" ]; then
    source "$SCRIPT_DIR/_/common.sh"
fi

# Skip if explicitly disabled
if [ "${SKIP_TRIAGE:-0}" = "1" ]; then
    exit 0
fi

# Rate limiting
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/huskycat/triage"
RATE_FILE="$CACHE_DIR/last_triage"
mkdir -p "$CACHE_DIR"

if [ -f "$RATE_FILE" ]; then
    last=$(cat "$RATE_FILE" 2>/dev/null || echo "0")
    now=$(date +%s)
    if [ $((now - last)) -lt 10 ]; then
        exit 0
    fi
fi
date +%s > "$RATE_FILE"

# Triage function using HuskyCat Python module
run_triage() {
    local log_file="$CACHE_DIR/$(date +%Y%m%d).log"
    local repo_root
    repo_root=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

    # Use UV to run triage engine
    if command -v uv &>/dev/null; then
        cd "$repo_root"
        HUSKYCAT_TRIAGE=1 uv run python3 -c "
from src.huskycat.core.triage import TriageEngine, TriageConfig
import os
config = TriageConfig(dry_run=os.environ.get('TRIAGE_DRY_RUN', '0') == '1')
engine = TriageEngine(config=config)
result = engine.run_post_commit()
if result.labels_inferred or result.issue_ref or result.mr_ref:
    print(result.summary())
" >> "$log_file" 2>&1 || true
    fi
}

# Run in background unless debugging
if [ "${TRIAGE_FOREGROUND:-0}" = "1" ]; then
    run_triage
else
    run_triage &
    disown 2>/dev/null || true
fi

# Post-commit hooks must never block
exit 0
